{
  "version": "1.8.0",
  "revision": 60,
  "structure": [
    {
      "type": "sketch",
      "name": "_shaders_matcap_003",
      "mod": 1771366645440,
      "code": "/*\r\nRichard and Anabel Algorave visuals\r\n*/\r\nlet myShader\r\nlet matcap, obj\r\nlet matcap1, obj1\r\nlet matcap2, obj2\r\nlet matcap3, obj3\r\nlet matcap4, obj4\r\nlet matcap5, obj5\r\nlet matcap6, obj6\r\n\r\nfunction preload() {\r\n\tmatcap = loadImage(\"data/images/radiolarian.png\")\r\n\tobj = loadModel(\"data/obj/radiolarian.obj\")\r\n\tmatcap1 = loadImage(\"data/images/pteropod.png\")\r\n\tobj1 = loadModel(\"data/obj/pteropod.obj\")\r\n\tmatcap2 = loadImage(\"data/images/dinoflagellates1.png\")\r\n\tobj2 = loadModel(\"data/obj/Dinoflagellates1.obj\")\r\n\tmatcap3 =loadImage(\"data/images/dinoflagellates2.png\")\r\n\tobj3 = loadModel(\"data/obj/dinoflagellates2.obj\")\r\n\tmatcap4 =loadImage(\"data/images/dinoflagellates3.png\")\r\n\tobj4 =loadModel(\"data/obj/Dinoflagellates3.obj\")\r\n\tmatcap5 =loadImage(\"data/images/dinoflagellates4.png\")\r\n\tobj5 =loadModel(\"data/obj/Dinoflagellates4.obj\")\r\n\tmatcap6 =loadImage(\"data/images/copepod.png\")\r\n\tobj6 =loadModel(\"data/obj/copepod.obj\")\r\n}\r\n\r\nfunction setup() {\r\n\tcreateCanvas(windowWidth, windowHeight, WEBGL)\r\n\t//pixelDensity() // fixes retina display offset\r\n\tnoStroke() // avoid strokes on 3d objects\r\n\t// set shader vert/frag from definitions below\r\n\tmyShader = createShader(vertShader, fragShader)\r\n}\r\n\r\nfunction draw() {\r\n\tbackground(0)\r\n\tshader(myShader) // set active shader\r\n\torbitControl(5) // use mouse to rotate\r\n\r\n\t// --- radiolarian (left) ---\r\n\tpush()\r\n\ttranslate(-width / 4, 0, 0)\r\n\trotateX(radians(frameCount / 1))\r\n\trotateZ(radians(frameCount / 1))\r\n\tscale(10)\r\n\tmyShader.setUniform(\"uMatcapTexture\", matcap)\r\n\tmodel(obj)\r\n\tpop()\r\n\r\n\t// --- pteropod (right) ---\r\n\tpush()\r\n\ttranslate(width / 4, 0, 0)\r\n\trotateX(radians(-frameCount / 3))\r\n\trotateZ(radians(frameCount / 1))\r\n\tscale(10)\r\n\tmyShader.setUniform(\"uMatcapTexture\", matcap1)\r\n\tmodel(obj1)\r\n\tpop()\r\n\t\r\n\t// dinoflagellates1\r\n\tpush()\r\n\ttranslate(width / 4, 0, 0)\r\n\trotateX(radians(-frameCount / 2))\r\n\trotateZ(radians(frameCount / 2))\r\n\tscale(5)\r\n\tmyShader.setUniform(\"uMatcapTexture\", matcap2)\r\n\tmodel(obj2)\r\n\tpop()\r\n\t\r\n\t// dinoflagellates2\r\n\tpush()\r\n\ttranslate(width / 4, 0, 0)\r\n\trotateX(radians(-frameCount / 2))\r\n\trotateZ(radians(frameCount / 1))\r\n\tscale(5)\r\n\tmyShader.setUniform(\"uMatcapTexture\", matcap3)\r\n\tmodel(obj3)\r\n\tpop()\r\n\t\r\n\t// dinoflagellates3\r\n\tpush()\r\n\ttranslate(width / 4, 0, 0)\r\n\trotateX(radians(-frameCount / 3))\r\n\trotateZ(radians(frameCount / 1))\r\n\tscale(2)\r\n\tmyShader.setUniform(\"uMatcapTexture\", matcap4)\r\n\tmodel(obj4)\r\n\tpop()\r\n\t\r\n\t// dinoflagellates5\r\n\tpush()\r\n\ttranslate(width / 4, 0, 0)\r\n\trotateX(radians(-frameCount / 3))\r\n\trotateZ(radians(frameCount / 2))\r\n\tscale(5)\r\n\tmyShader.setUniform(\"uMatcapTexture\", matcap5)\r\n\tmodel(obj5)\r\n\tpop()\r\n\t\r\n\t// dinoflagellates6\r\n\tpush()\r\n\ttranslate(width / 4, 0, 0)\r\n\trotateX(radians(-frameCount / 3))\r\n\trotateZ(radians(frameCount / 2))\r\n\tscale(10)\r\n\tmyShader.setUniform(\"uMatcapTexture\", matcap6)\r\n\tmodel(obj6)\r\n\tpop()\r\n\t\r\n}\r\n\r\n/* SHADER DEFINITIONS */\r\nlet vertShader = `\r\n\t// get position attribute of the geometry\r\n\tattribute vec3 aPosition;\r\n\t\r\n\t// get texture coordinate attribute from the geometry\r\n\tattribute vec2 aTexCoord;\r\n\t\r\n\t// get vertex normal attribute from the geometry\r\n\tattribute vec3 aNormal;\r\n\t\r\n\t// uProjectionMatrix to convert 3d world coords to screen coords \r\n\tuniform mat4 uProjectionMatrix;\r\n\t\r\n\t// uModelViewMatrix combines model matrix and view matrix\r\n\t// model matrix defines object position / rotation / scale\r\n\t// view matrix defines camera focal length / position\r\n\tuniform mat4 uModelViewMatrix;\r\n\t\r\n\t// normalmatrix is the transpose-inverse of the modelview matrix. \r\n\t// It's currently broken in p5, but normally used in these calculations\r\n\tuniform mat4 uNormalMatrix;\r\n\t\r\n\t// pass the normal and the eye to the fragment shader\r\n\tvarying vec3 vNormal;\r\n\tvarying vec3 vEye;\r\n\t\r\n\tvoid main() {\r\n\t\t// calculate world space eye position and world space normal\r\n\t\tvEye = normalize( vec3(uModelViewMatrix * vec4(aPosition, 1.0)));\r\n\t\r\n\t\t// typically use uNormalMatrix instead of uModelViewMatrix but currently there is a bug\r\n\t\tvNormal = normalize((uModelViewMatrix * vec4(aNormal, 0.0)).xyz);\r\n\t\r\n\t\t// copy position data into a vec4, using 1.0 as the w component\r\n\t\tvec4 positionVec4 = vec4(aPosition, 1.0);\r\n\t\r\n\t\t// move our vertex positions into screen space\r\n\t\t// order of multiplication is always projection * view * model * position\r\n\t\t// (model and view) have been combined so we just do projection * modelView * position\r\n\t\tgl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\r\n\t}\r\n`\r\n\r\nlet fragShader = `\r\n\tprecision mediump float;\r\n\t\r\n\t// get normal from the vertex shader\r\n\tvarying vec3 vNormal;\r\n\tvarying vec3 vEye;\r\n\t\r\n\tuniform sampler2D uMatcapTexture;\r\n\t\r\n\t// returns texture coordinates. \r\n\t// input eye position and normal, returns how a sphere reflects the texture. \r\n\t// implementation borrowed from https://www.clicktorelease.com/blog/creating-spherical-environment-mapping-shader/\r\n\tvec2 matcap(vec3 eye, vec3 normal) {\r\n\t\tvec3 reflected = reflect(eye, normal);\r\n\t\tfloat m = 2.8284271247461903 * sqrt( reflected.z+1.0 );\r\n\t\treturn reflected.xy / m + 0.5;\r\n\t}\r\n\t\r\n\tvoid main() {\r\n\t\t// calculate our uv\r\n\t\tvec2 uv = matcap(vEye, vNormal);\r\n\t\r\n\t\t// sample the texture\r\n\t\tvec4 color = texture2D(uMatcapTexture, uv);\r\n\t\t\r\n\t\t// draw the texcoords to the screen\r\n\t\tgl_FragColor = color;\r\n\t}\r\n`"
    },
    {
      "name": "_shaders_matcap_002",
      "mod": "1770769667483",
      "type": "sketch",
      "code": "let myShader\r\nlet matcap, obj\r\nlet matcap1, obj1\r\n\r\nfunction preload() {\r\n  matcap = loadImage(\"includes/demos-data/images/fish.png\")\r\n  obj = loadModel(\"includes/demos-data/3d/teapot.obj\")\r\n  matcap1 = loadImage(\"data/images/imagen3.png\")\r\n  obj1 = loadModel(\"data/obj/algorave1.obj\")\r\n}\r\n\r\nfunction setup() {\r\n  createCanvas(windowWidth, windowHeight, WEBGL)\r\n  pixelDensity(1)\r\n  noStroke()\r\n  myShader = createShader(vertShader, fragShader)\r\n}\r\n\r\nfunction draw() {\r\n  background(0)\r\n  shader(myShader)\r\n  orbitControl(5)\r\n\r\n  // --- First model ---\r\n  push()\r\n    myShader.setUniform(\"uMatcapTexture\", matcap)\r\n    rotateX(radians(frameCount / 2))\r\n    rotateZ(radians(frameCount / 4))\r\n    translate(-150, 0, 0)\r\n    scale(5)\r\n    model(obj)\r\n  pop()\r\n\r\n  // --- Second model ---\r\n  push()\r\n    myShader.setUniform(\"uMatcapTexture\", matcap1)\r\n    rotateX(radians(frameCount / 2))\r\n    rotateZ(radians(frameCount / 4))\r\n    translate(150, 0, 0)\r\n    scale(5)\r\n    model(obj1)\r\n  pop()\r\n  \r\n\r\n}\r\n\r\n/* SHADER DEFINITIONS */\r\nlet vertShader = `\r\n  attribute vec3 aPosition;\r\n  attribute vec2 aTexCoord;\r\n  attribute vec3 aNormal;\r\n\r\n  uniform mat4 uProjectionMatrix;\r\n  uniform mat4 uModelViewMatrix;\r\n  uniform mat4 uNormalMatrix;\r\n\r\n  varying vec3 vNormal;\r\n  varying vec3 vEye;\r\n\r\n  void main() {\r\n    vEye = normalize(vec3(uModelViewMatrix * vec4(aPosition, 1.0)));\r\n    vNormal = normalize((uModelViewMatrix * vec4(aNormal, 0.0)).xyz);\r\n    vec4 positionVec4 = vec4(aPosition, 1.0);\r\n    gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\r\n  }\r\n`\r\n\r\nlet fragShader = `\r\n  precision mediump float;\r\n\r\n  varying vec3 vNormal;\r\n  varying vec3 vEye;\r\n\r\n  uniform sampler2D uMatcapTexture;\r\n\r\n  vec2 matcap(vec3 eye, vec3 normal) {\r\n    vec3 reflected = reflect(eye, normal);\r\n    float m = 2.8284271247461903 * sqrt(reflected.z + 1.0);\r\n    return reflected.xy / m + 0.5;\r\n  }\r\n\r\n  void main() {\r\n    vec2 uv = matcap(vEye, vNormal);\r\n    vec4 color = texture2D(uMatcapTexture, uv);\r\n    gl_FragColor = color;\r\n  }\r\n`"
    },
    {
      "name": "_shaders_matcap_001",
      "mod": "1770685081096",
      "type": "sketch",
      "code": "/*\n\t_shader_matcap // cc teddavis.org 2020\t\n\tMatcap (material capture) shader remixed from Adam Ferriss' p5jsShaderExamples\n\thttps://github.com/aferriss/p5jsShaderExamples\n\n\tcollection of matcaps\n\thttps://github.com/nidorx/matcaps\n*/\n\nlet myShader\nlet matcap, obj\n\nfunction preload() {\n\tmatcap = loadImage(\"data/images/imagen2.jpg\")\n\tobj = loadModel(\"data/obj/algorave1.obj\")\n}\n\nfunction setup() {\n\tcreateCanvas(windowWidth, windowHeight, WEBGL)\n\tpixelDensity(1) // fixes retina display offset\n\tnoStroke() // avoid strokes on 3d objects\n\n\t// set shader vert/frag from definitions below\n\tmyShader = createShader(vertShader, fragShader)\n}\n\nfunction draw() {\n\tbackground(0)\n\n\tshader(myShader) // set active shader\n\tmyShader.setUniform(\"uMatcapTexture\", matcap) // send texture to shader\n\n\torbitControl(5) // use mouse to rotate\n\trotateX(radians(frameCount / 2))\n\trotateZ(radians(frameCount / 4))\n\n\t// shader applied to any primatives\n\t// sphere(height, 16, 16)\n\n\tscale(5)\n\tmodel(obj)\n}\n\n\n/* SHADER DEFINITIONS */\n\nlet vertShader = `\n\t// getposition attribute of the geometry\n\tattribute vec3 aPosition;\n\t\n\t// get texture coordinate attribute from the geometry\n\tattribute vec2 aTexCoord;\n\t\n\t// get vertex normal attribute from the geometry\n\tattribute vec3 aNormal;\n\t\n\t// uProjectionMatrix to convert 3d world coords to screen coords \n\tuniform mat4 uProjectionMatrix;\n\t\n\t// uModelViewMatrix combines model matrix and view matrix\n\t// model matrix defines object position / rotation / scale\n\t// view matrix defines camera focal length / position\n\tuniform mat4 uModelViewMatrix;\n\t\n\t// normalmatrix is the transpose-inverse of the modelview matrix. \n\t// It's currently broken in p5, but normally used in these calculations\n\tuniform mat4 uNormalMatrix;\n\t\n\t// pass the normal and the eye to the fragment shader\n\tvarying vec3 vNormal;\n\tvarying vec3 vEye;\n\t\n\tvoid main() {\n\t\t// calculate world space eye position and world space normal\n\t\tvEye = normalize( vec3(uModelViewMatrix * vec4(aPosition, 1.0)));\n\t\n\t\t// typically use uNormalMatrix instead of uModelViewMatrix but currently there is a bug\n\t\tvNormal = normalize((uModelViewMatrix * vec4(aNormal, 0.0)).xyz);\n\t\n\t\t// copy position data into a vec4, using 1.0 as the w component\n\t\tvec4 positionVec4 = vec4(aPosition, 1.0);\n\t\n\t\t// move our vertex positions into screen space\n\t\t// order of multiplication is always projection * view * model * position\n\t\t// (model and view) have been combined so we just do projection * modelView * position\n\t\tgl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n\t}\n`\n\n\nlet fragShader = `\n\tprecision mediump float;\n\t\n\t// get normal from the vertex shader\n\tvarying vec3 vNormal;\n\tvarying vec3 vEye;\n\t\n\tuniform sampler2D uMatcapTexture;\n\t\n\t// returns texture coordinates. \n\t// input eye position and normal, returns how a sphere reflects the texture. \n\t// implementation borrowed from https://www.clicktorelease.com/blog/creating-spherical-environment-mapping-shader/\n\tvec2 matcap(vec3 eye, vec3 normal) {\n\t\tvec3 reflected = reflect(eye, normal);\n\t\tfloat m = 2.8284271247461903 * sqrt( reflected.z+1.0 );\n\t\treturn reflected.xy / m + 0.5;\n\t}\n\t\n\tvoid main() {\n\t\t// calculate our uv\n\t\tvec2 uv = matcap(vEye, vNormal) ;\n\t\n\t\t// sample the texture\n\t\tvec4 color = texture2D(uMatcapTexture, uv);\n\t\t\n\t\t// draw the texcoords to the screen\n\t\tgl_FragColor = color;\n\t}\n`"
    }
  ],
  "count": {
    "sketches": 3,
    "folders": 0
  }
}